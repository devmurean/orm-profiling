#!/usr/bin/env php

<?php
require "../vendor/autoload.php";

use Faker\Factory;
use Faker\Generator;

class Profiler
{
    /** @var Generator Faker instance */
    private Generator $faker;

    private string $host;
    private string $db;
    private string $db_username;
    private string $db_password;
    private string $xdebug;
    private bool $memory;


    /** @var int How many iteration a test is done */
    private int $n;

    private array $endpoints = [
        // CRUD Group
        'crud' => [
            ['method' => 'get', 'name' => 'read', 'value' => '/user'],
            ['method' => 'get', 'name' => 'lookup', 'value' => '/user/lookup'],
            ['method' => 'post', 'name' => 'create', 'value' => '/user'],
            ['method' => 'put', 'name' => 'update', 'value' => '/user'],
            ['method' => 'post', 'name' => 'delete', 'value' => '/user/delete'],
        ],

        // ST Group
        'st' => [
            ['method' => 'get', 'name' => 'read', 'value' => '/st'],
            ['method' => 'get', 'name' => 'lookup', 'value' => '/st/lookup'],
            ['method' => 'post', 'name' => 'create', 'value' => '/st'],
            ['method' => 'put', 'name' => 'update', 'value' => '/st'],
            ['method' => 'post', 'name' => 'delete', 'value' => '/st/delete'],
        ],

        // TPC Group
        'tpc' => [
            ['method' => 'get', 'name' => 'read', 'value' => '/tpc'],
            ['method' => 'get', 'name' => 'lookup', 'value' => '/tpc/lookup'],
            ['method' => 'post', 'name' => 'create', 'value' => '/tpc'],
            ['method' => 'put', 'name' => 'update', 'value' => '/tpc'],
            ['method' => 'post', 'name' => 'delete', 'value' => '/tpc/delete'],
        ],

        // TPCC Group
        'tpcc' => [
            ['method' => 'get', 'name' => 'read', 'value' => '/tpcc'],
            ['method' => 'get', 'name' => 'lookup', 'value' => '/tpcc/lookup'],
            ['method' => 'post', 'name' => 'create', 'value' => '/tpcc'],
            ['method' => 'put', 'name' => 'update', 'value' => '/tpcc'],
            ['method' => 'post', 'name' => 'delete', 'value' => '/tpcc/delete'],
        ],

        // Propagation Group
        'propagation' => [
            ['method' => 'post', 'name' => 'create', 'value' => '/propagation/add'],
            ['method' => 'post', 'name' => 'update', 'value' => '/propagation/update'],
            ['method' => 'post', 'name' => 'delete', 'value' => '/propagation/delete'],
        ],

        // Isolation Group
        // 'isolation' => [
        //     [
        //         'method' => 'post',
        //         'name' => 'create',
        //         'value' => '/isolation/add'
        //     ],
        //     [
        //         'method' => 'post',
        //         'name' => 'update',
        //         'value' => '/isolation/update'
        //     ],
        //     [
        //         'method' => 'post',
        //         'name' => 'delete',
        //         'value' => '/isolation/delete'
        //     ],
        // ],

    ];

    /** @var array Record count in related database table */
    private array $records = [100, 1000, 10000, 100000];

    private array $orms = ['doctrine', 'eloquent'];

    public function __construct(string $host, string $db, string $db_username, string $db_password, int $n, string $xdebug = '', bool $memory = false)
    {
        $this->faker = Factory::create();
        $this->host = $host;
        $this->db = $db;
        $this->db_username = $db_username;
        $this->db_password = $db_password;
        $this->n = $n;
        $this->xdebug = $xdebug;
        $this->memory = $memory;
    }

    private function seeding(string $group, int $recordCount)
    {
        // e.g. preparing database for <<CRUD>> profiling with <<100>> records
        echo 'Preparing database for ' . $group . ' profiling with ' . $recordCount . ' records...' . PHP_EOL;

        $dumpFilePath = './mysql-dump/' . $recordCount . '_' . $group . '.sql';
        $command = "mysql -u {$this->db_username} --password={$this->db_password} {$this->db} < {$dumpFilePath}";
        // $command = 'mysql -u ' . $this->db_username . ' --password=' . $this->db_password . ' ' . $this->db . ' < ' . $dumpFilePath;

        exec($command);
    }

    private function writeToFile(string $target, array $data)
    {
        $data = json_encode($data);
        $f = fopen($target, 'w');
        fwrite($f, $data);
        fclose($f);
    }

    private function checkDirectoryExistence()
    {
        $this->sentence('Checking directories');
        $directories = ['memory-profiling-result', 'xdebug-profiling-result', 'load-profiling-result', 'inputs', 'reports'];
        foreach ($directories as $dir) {
            if (!file_exists($dir)) {
                mkdir($dir);
                $this->sentence($dir . ' directory has been created');
            }
        }
        $this->sentence('Directories check done');
    }

    private function getOutputFolder()
    {
        if ($this->memory) {
            return 'memory-profiling-result';
        } elseif ($this->xdebug) {
            return 'xdebug-profiling-result';
        } else {
            return 'load-profiling-result';
        }
    }

    /**
     * Profile endpoints within certain group
     *
     * @param string $group Name of group. e.g crud, st, tpc, tpcc, or propagation
     * @param array $data Collection of data that will get impacted in profiling process
     * @return void
     */
    public function profile(string $group, array $data = []): void
    {
        $this->checkDirectoryExistence();

        // Turn on xdebug / memmory logging
        $this->specialSetupOn();

        foreach ($this->records as $record) {
            foreach ($this->orms as $orm) {
                // Each ORM get fresh record
                $this->sentence("Seeding {$record} database record for {$group} group");
                $this->seeding($group, $record);
                $this->sentence("Seeding done");

                $this->sentence("Profiling {$group} group with {$record} database record");
                $this->sentence("Running Apache Benchmark commands for {$orm} with {$this->n} iterations for each endpoint");
                foreach ($this->endpoints[$group] as $e) {
                    for ($i = 0; $i < $this->n; $i++) {
                        $iterationNumber = $i + 1;
                        $inputFileName = "inputs/{$group}.{$orm}.json";
                        if (in_array($e['name'], ['update', 'create'])) {
                            $dataToWrite = $group === 'propagation' ? [] : $data[$orm][$i];
                            $this->writeToFile($inputFileName, $dataToWrite);
                        }
                        $command = 'ab -n 1 -c 1 ';
                        $command .= $e['method'] === 'post' ? '-p ' : '';
                        $command .= $e['method'] === 'put' ? '-u ' : '';
                        $command .= in_array($e['method'], ['post', 'put']) ? "{$inputFileName} -T application/json " : '';
                        $command .= "{$this->host}/{$orm}{$e['value']}";
                        // Add record ID as route parameter
                        $id = $i + 1;
                        $command .= in_array($e['name'], ['lookup', 'update', 'delete']) ? "/{$id}" : '';

                        $command .= " > {$this->getOutputFolder()}/{$group}.{$record}.ab.{$e['name']}." . $orm . '-' . $i . ".txt";

                        exec($command);
                        $this->sentence("Group: {$group}, Endpoint: {$e['name']}, iteration {$iterationNumber} done");
                    }
                    $this->sentence('---');
                }
            }

            $this->sentence("Profiling {$group} group with {$record} database record done");
        }
        $this->sentence("Profiling {$group} group done");

        // Turn off xdebug / memory logging
        $this->specialSetupOff();
    }

    private function sentence(string $sentence = '')
    {
        echo $sentence . '...' . PHP_EOL;
    }

    /**
     * Collect data based on closure result
     *
     * @param Closure $callback
     * @param integer $n
     * @return array
     */
    private function collectData(Closure $callback): array
    {
        $data = [];
        foreach ($this->orms as $orm) {
            for ($i = 0; $i < $this->n; $i++) {
                $data[$orm][] = $callback();
            }
        }
        return $data;
    }

    public function crud()
    {
        $this->profile('crud', $this->collectData(fn () => [
            'name' => $this->faker->name,
            'email' => $this->faker->uuid() . '@example.com'
        ]));
    }

    public function st()
    {
        $this->profile('st', $this->collectData(fn () => [
            'name' => $this->faker->name,
            'address' => $this->faker->address,
            'nik' => rand(10 ** 5, 10 ** 6 - 1),
            'contract_duration' => 1,
        ]));
    }

    public function tpc()
    {
        $this->profile('tpc', $this->collectData(fn () => [
            'name' => $this->faker->name,
            'address' => $this->faker->address,
            'nik' => rand(10 ** 5, 10 ** 6 - 1),
        ]));
    }

    public function tpcc()
    {
        $this->profile('tpcc', $this->collectData(fn () => [
            'name' => $this->faker->name,
            'address' => $this->faker->address,
            'nik' => rand(10 ** 5, 10 ** 6 - 1),
        ]));
    }

    public function propagation()
    {
        $this->profile('propagation');
    }

    private function xdebugSetup(bool $turnoff = false)
    {
        if (!$this->xdebug) {
            return;
        }
        $filename = $this->xdebug;
        // $filename = '/etc/php/8.2/cli/conf.d/20-xdebug.ini';
        $filelines = file($filename);

        $matches  = preg_grep('/^(xdebug.mode|xdebug.output_dir)/', $filelines);

        foreach ($matches as $key => $value) {
            if (str_contains($value, 'xdebug.mode')) {
                $mode = $turnoff ? 'off' : 'profile';
                $filelines[$key] = 'xdebug.mode=' . $mode . PHP_EOL;
            }
            if (str_contains($value, 'xdebug.output_dir')) {
                $dir = realpath('./xdebug-profiling-result');
                $filelines[$key] = 'xdebug.output_dir=' . $dir . PHP_EOL;
            }
        }

        $newContent = implode('', $filelines);
        file_put_contents($filename, $newContent);
        exec('sudo systemctl restart apache2');
    }

    private function memoryLoggingSetup(bool $turnoff = false)
    {
        if (!$this->memory) {
            return;
        }

        $filename = '../.env';
        $filelines = file($filename);
        $matches  = preg_grep('/^(LOG_MEMORY_USAGE)/', $filelines);

        foreach ($matches as $key => $value) {
            if (str_contains($value, 'LOG_MEMORY_USAGE')) {
                $mode = $turnoff ? 'false' : 'true';
                $filelines[$key] = 'LOG_MEMORY_USAGE=' . $mode . PHP_EOL;
            }
        }

        $newContent = implode('', $filelines);
        file_put_contents($filename, $newContent);
    }

    private function specialSetupOn()
    {
        $this->xdebugSetup();
        $this->memoryLoggingSetup();
    }

    private function specialSetupOff()
    {
        $this->xdebugSetup(turnoff: true);
        $this->memoryLoggingSetup(turnoff: true);
    }
}


/** @var array Command line options */
$options = getopt('', [
    'db:',
    'db_password:',
    'db_username:',
    'host:',
    'n:',
    'xdebug:', // xdebug path
    'memory'
]);

$profiler = new Profiler(
    host: $options['host'],
    db: $options['db'],
    db_username: $options['db_username'],
    db_password: $options['db_password'],
    n: array_key_exists('n', $options) ? $options['n'] : 10,
    xdebug: array_key_exists('xdebug', $options) ? $options['xdebug'] : '',
    memory: array_key_exists('memory', $options) ?? false,
);

$profiler->crud();
$profiler->st();
$profiler->tpc();
$profiler->tpcc();
$profiler->propagation();
